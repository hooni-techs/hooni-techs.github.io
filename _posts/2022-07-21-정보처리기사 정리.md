---
layout: post
title: 정보처리기사 정리
author: 후니테크
description: 정보처리기사 정리
tags: [exam]
featuredImage: 
img: 
categories: Exam
date: '2022-07-21'
extensions:
  preset: gfm

---

[정보처리기사] 내용 정리
======================

#  테스트 기법

* 화이트박스 테스팅 ( White-Box Testing )

   - 구조 기반 기법, 개발자 관점에서의 단위 테스팅 기법

   - 소프트웨어 내부 소스 코드를 보면서 필요한 정보들을 사용

   - 컴포넌트(단위) 또는 소프트웨어의 구조를 중심으로 테스트 케이스를 도출

 

* 구조 기반 기법

   - 소프트웨어 코드나 설계 등 구조를 보여주는 정보로부터 테스트 케이스를 도출

   - 커버리지를 높이기 위해 테스트 케이스를 시스템적으로 도출 추가 가능

 

[ 구조 기반 기법 기본 ]

* 구조 기반 기법 ( Structure-based technique )

   - 코드와 개발 설계 등의 소프트웨어 구현 정보를 기반으로 테스트 케이스를 설계하는 기법

 

* 구문 테스팅과 커버리지 ( Statement testing and coverage )

   -  프로그램 내의 모든 문장들을 한 번 이상 수행하도록 테스트 케이스를 설계하는 기법

 

* 결정 테스팅과 커버리지 ( Decision testing and coverage )

   - 프로그램 내의 각 분기들을 한 번 이상 수행하도록 테스트 케이스를 설계하는 기법

   - 전체 조건식이 최소한 참이 한 번 그리고 거짓이 한 번 선택되었는지 측정하여 퍼센트로 표현


* 조건 테스팅과 커버리지 ( Condition testing and coverage )

   - 조건들이 참이 되는 경우와 거짓이 되는 경우를 모두 수행하도록 테스트 케이스를 설계하는 기법

   - 전체 조건식의 결과와 관계없이 각 개별 조건식이 참 한번, 거짓 한 번을 모두 갖도록 함


* 다중 조건 커버리지 ( Multiple condition coverage )

   - 프로그램 내의 모든 개별 조건식의 모든 가능한 논리적 조합을 고려한 강력한 커버리지

   - 출시 전에 반드시 100% 결함을 제거해야 하는 제품 테스트에서 주로 사용


* 변형 조건/결정 커버리지 ( Modified Condition/Decision Coverage )

   - 각 개별 조건식이 다른 개별 조건식에 무관하게 전체 조건식의 결과에 독립적으로 영향을 줌


[ 구조 기반 기법 고급 ]

* 분할 ( Splitting ) 방법으로 접근한 조건/결정 커버리지

   - 분할 ( Splitting ) : 생성한 모든 논리적 조합을 분할하여 테스트 케이스를 작성하는 방식

   결함의 원인 판단은 빠르지만 테스트 케이스 수가 크게 증가하게 됨

 

* 포함 ( Including ) : 생성한 조합 중 단 하나만 선택하여 하나의 논리적 테스트 케이스를 작성

   결함의 원인 판단이 느리지만 적당한 커버리지 만족과 테스트 케이스 수를 가짐




# 응집도, 결합도 순서

- 응집도 : 정보은닉 개념 확장, 응집도가 강할수록 품질이 좋음

[ 응집도가 강한 순서 -> 약한 순서]

functional – sequential – communication – procedural – temporal – logical – coincidental

기능-단일 / 순차-나온것 입력으로 / 통신-동일한입출력 다른기능수행

절차-다수의 관련기능 순차수행 / 시간-특정시간 / 논리-유사한 성격 / 우연-서로 관련 없는 요소

- 기능적 : 모듈 내부의 모든 기능 요소들이 단일 문제와 연관되어 수행될 경우

- 순차적 : 모듈 내 하나의 활동으로부터 나온 출력 데이터를 그 다음활동의 입력 데이터로 사용할 경우

- 통신적(교환적) : 동일한 입출력을 사용하여 서로 다른 기능을 수행하는 구성 요소들이 모였을 경우

- 절차적 : 모듈이 다수의 관련 기능을 가질 때 모듈 안의 구성요소들이 그 기능을 순차적으로 수행할 경우

- 시간적 : 특정 시간에 처리되는 몇 개의 기능을 모아 하나의 모듈로 작성한 경우

- 논리적 : 유사한 성격을 갖거나 특정 형태로 분류되는 처리요소들이 하나의 모듈이 되는 경우

- 우연적 : 모듈 내부의 각 구성요소들이 서로 관련 없는 요소로만 구성된 경우

기순통절시논우
 

- 결합도 : 상호의존의 정도, 결합도가 약해야 품질이 상승

[ 결합도가 약한 순서 -> 강한 순서 ]

data – stamp – control – external – common - content

자료-데이터 / 스탬프-자료구조 / 제어-다른 모듈에서 흐름 파악 / 외부-참조 / 공통-공유되는 / 내용-직접참조,다른모듈에서 사용

- 자료: 어떤 모듈이 다른 모듈을 호출하면서 매개 변수나 인수로 데이터를 넘겨주고, 호출 받은 모듈은 받은 데이터에 대한 처리 결과를 다시 돌려주는 방식

- 스탬프: 두 모듈이 동일한 자료 구조를 조회하는 경우

- 제어: 한 모듈이 다른 모듈의 상세한 처리 절차를 알고 있어 이를 통제하는 경우나 처리 기능이 두 모듈에 분리되어 설계된 경우, 다른 모듈에서 흐름을 제어

- 외부: 어떤 모듈에서 선언한 데이터를 외부의 다른 모듈에서 참조할 때

- 공통: 공유되는 공통 데이터 영역을 여러 모듈이 사용할 때

- 내용: 한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 직접 참조하거나 수정할 때

( 다른 모듈에서 사용하는 경우 )

자자제외공직


# 정규화 및 이상

1. 삽입 이상

말그대로 어떠한 릴레이션에 데이터를 집어넣었더니 이상한 값들도 같이 딸려들어가는 현상입니다.

2. 삭제 이상

하나의 행을 삭제했더니, 갑자기 뜬금없이 다른 행들도 다다다닥! 삭제되는 현상입니다.

3. 갱신이상

새로고침했더니, 속성값의 일부분만 갱신되어 전체의 릴레이션의 정보가 어긋나는 현상입니다.

1. 비정규 릴레이션



                                       ↓       (도메인이 원자값)


2. 1NF



                                       ↓       (부분적 함수 종속 제거)



3. 2NF



                                       ↓       (이행적 함수 종속 제거)



4. 3NF



                                       ↓       (결정자들 중에서 후보키가 아니라면 싹다제거)



5. BCNF



                                       ↓       (다치 종속 제거)



6. 4NF



                                       ↓       (조인 종속성 이용)



7. 5NF

## <span style="color: red;">도부이결다조</span>   
## <span style="color: red;">두부이거다줘</span>   


# 디자인 패턴


* MVC 패턴 : Model, View, Controller로 이루어진 패턴

생성 패턴
(Creational Pattern) 구조 패턴
(Structural Pattern) 행위 패턴
(Behavioral Pattern)
객체의 생성과 관련된 패턴 클래스나 객체들을 조합하여
더 큰 구조로 만들 수 있게 해주는 패턴  클래스나 객체들이 서로 상호작용하는
방법이나 책임 분배 방법을 정의하는 패턴
- 추상 팩토리(Abstract Factory)
- 빌더(Builder)
- 팩토리 메소드(Factory Method)
- 프로토타입(Prototype)
- 싱글톤(Singleton)  - 어댑터(Adapter)
- 브리지(Bridege)
- 컴포지트(Composite)
- 데코레이터(Decorator)
- 퍼싸드(Facade)
- 플라이웨이트(Flyweight)
- 프록시(Proxy)   - 책임 연쇄(Chain of Responsibility)
- 커맨드(Command)
- 인터프리터(Interpreter)
- 반복자(Iterator)
- 중재자(Mediator)
- 메멘토(Memento)
- 옵서버(Observer)
- 상태(State)
- 전략(Strategy)
- 템플릿 메소드(Template Method)
- 방문자(Visitor)
< 생성 패턴 >

* 추상 팩토리

- 동일한 주제의 다른 팩토리를 묶어줌

- 구체적인 클래스에 의존하지 않고 서로 연관되거나 의존적인 객체들의 조합을 만드는 인터페이스를 제공하는 패턴

 

* 빌더

- 생성과 표기를 분리해 복잡한 객체를 생성

 

* 팩토리 메소드

- 생성할 객체의 클래스를 국한하지 않고 객체를 생성

- 객체 생성 처리를 서브 클래스로 분리해 처리하도록 캡슐화하는 패턴

 

* 프로토타입

- 기존 객체를 복제함으로써 객체를 생성

 

* 싱글톤

- 한 클래스에 한 객체만 존재하도록 제한

- 전역 변수를 사용하지 않고 객체를 하나만 생성하도록 하며, 생성된 객체를 어디에서든지 참조할 수 있도록 하는 패턴

 

< 구조 패턴 >

* 어댑터

- 인터페이스가 호환되지 않는 클래스들을 함께 이용할 수 있도록, 타 클래스의 인터페이스를 기존 인터페이스에 덧씌움

 

* 브리지

- 추상화와 구현을 분리해 둘을 각각 따로 발전시킬 수 있음

 

* 컴포지트

- 0개, 1개 혹은 그 이상의 객체를 묶어 하나의 객체로 이용할 수 있음

- 여러 개의 객체들로 구성된 복합 객체와 단일 객체를 클라리언트에서 구별없이 다루게 해주는 패턴

 

* 데코레이터

- 기존 객체의 매서드에 새로운 행동을 추가하거나 오버라이드 할 수 있음

 

* 퍼싸드

- 많은 분량의 코드에 접근할 수 있는 단순한 인터페이스를 제공

 

* 플라이웨이트

- 다수의 유사한 객체를 생성, 조작하는 비용을 절감할 수 있음

 

* 프록시

- 접근 조절, 비용 절감, 복잡도 감소를 위해 접근이 힘든 객체에 대한 대역을 제공함

 

< 행위 패턴 >

* 커맨드

- 위의 명령어를 각각 구현하는 것보다는 위 그림처럼 하나의 추상 클래스에 메서드를 하나 만들고 각 명령이 들어오면 그에 맞는 서브 클래스가 선택되어 실행하는 것

- 실행될 기능을 캡슐화함으로써 주어진 여러 기능을 실행할 수 있는 재사용성이 높은 클래스를 설계하는 패턴

 

* Observer 패턴(2020 실기 1회 기출문제)

- 어떤 클래스에 변화가 일어났을 때, 이를 감지하여 다른 클래스에 통보해주는 것

- 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들에게 연락이 가고 자동으로 내용이 갱신되는 패턴

 

* 템플릿 메소드

- 상위 클래스에서는 추상적으로 표현하고, 그 구체적인 내용은 하위 클래스에서 결정되는 디자인 패턴

- 어떤 작업을 처리하는 일부분을 서브 클래스로 캡슐화해 전체 일을 수행하는 구조는 바꾸지 않으면서 특정 단계에서 수행하는 내역을 바꾸는 패턴* 디자인 패턴 종류 설명


# 패킷 교환 방식

[ 패킷 교환 방식 ]

- 패킷 : 네트워크를 통해 전송하기 쉽도록 자른 데이터 단위이며 수신하는 곳에서는 원래의 데이터로 다시 재조립됨

- 일정한 데이터 블록인 패킷을 교환기가 수신측 주소에 따라 적당한 통신경로를 선택하여 전송하는 교환방식

- 전송하고자 하는 정보를 일정한 크기의 데이터로 분할한 후, 송수신 주소인 헤더를 각각에 부가한 패킷단위로 전송하는 방식

 

* 가상 회선 방식 ( Virtual Circuit ) 

- 데이터를 전송하기 전에 논리적 연결이 설정됨 ( 연결 지향형 )

- 모든 패킷을 전송하면 가상회선이 해제되고 패킷들은 전송된 순서대로 도착함

 


 

* 데이터 그램 방식 ( Datagram )

- 데이터를 전송하기 전에 논리적 연결이 설정되지 않으며, 패킷이 독립적으로 전송됨

- 패킷을 수신한 라우터는 최적의 경로를 선택하여 패킷을 전송하는데, 하나의 메시지에서 분할된 여러 패킷은 서로 다른 경로로 전성될 수 있음 ( 비연결 지향형 )


 

[ 회선 교환 방식 ]

- 송수신 단말장치 사이에서 데이터를 전송할 때마다 통신경로를 설정하여 데이터를 교환하는 방식

- 통화로 동작에 의해 공간분할방식과 시분할방식으로 구분

# 테스트 정리


* 테스트 레벨 : 한 번에 총체적으로 조직화하고 관리하는 테스트 활동의 묶음

- 단위 테스트, 통합테스트, 시스템 테스트, 인수 테스트

 

* 단위 테스트(Unit Test)

- 코딩 직후 SW 설계의 최소 단위인 모듈이나 컴포넌트에 초점을 맞춰 테스트 진행

- 사용자 요구사항을 기반으로 한 기능성 테스트 최우선

- 주로 구조기반(화이트박스 테스트) 시행

 

* 통합 테스트

- 시스템이나 시스템 구성 요소 또는 소프트웨어 프로그램의 데이터 및 기능의 인터페이스(흐름)가 정상적으로 작동하는지에 중점을 둠

- 단위 테스트를 통과한 개발 소프트웨어/하드웨어 컴포넌트 간 인터페이스 및 연동 기능 등을 구조적으로 접근하여 테스트

-- 빅뱅 통합 테스트 : 모든 모듈을 한꺼번에 통합하고 결합 격리가 어려움

-- 상향식 통합 : 가장 하부의 모듈부터 통합해가면서 상부로 올라감, 드라이브가 필요

-- 하향식 통합 : 가장 상부의 모듈부터 통합해가면서 하부로 내려감, 스텁 필요

-- 백본 통합 : 소프트웨어 리스크가 높은 것을 우선적으로 통합하고 접근, 드라이버, 스텁은 필요에 따라 만들어서 사용

 

* 시스템 테스트

- 실제 환경과 가능한 유사한 환경에서 진행

- 기능적 요구사항(명세기반 기법), 비기능적 요구사항(구조기반 기법)

- 개발 조직과는 독립된 테스트 조직에서 수행되어야 하며 사전 요구사항이 명확해야 한다

- 단위, 통합 테스트가 가능한 완벽히 완료되어 가능상에 문제가 없는 상태여야 한다

 

* 추가 

* 테스트 하네스 

- 테스트를 지원하기 위한 코드와 데이터를 말하며 단위 테스트에 사용하기 위해 개발자가 작성

- 애플리케이션 컴포넌트 및 모듈을 테스트하는 환경의 일부분으로, 테스트를 지원하기 위한 코드와 데이터를 말하며, 단위 또는 모듈 테스트에 사용하기 위해 코드 개발자가 작성하는 요소

 

* 테스트 슈트

- 테스트 대상 컴포넌트나 시스템에 사용되는 테스트 케이스 집합

 

* 테스트 케이스

- 입력값, 실행 조건, 기대 결과 등의 집합

 

* 테스트 스크립트

- 자동화된 테스트 케이스의 절차와 실행 순서 명시

 

* 테스트 드라이버

- 상향식 통합 테스트에서 데이터의 입력과 출력을 확인하기 위해서 하위 모듈을 호출하는 상위의 더미 모듈

 

* 테스트 시나리오

- 테스트 수행을 위한 여러 테스트 케이스의 집합으로서, 테스트 케이스의 동작 순서를 기술한 문서이며 테스트를 위한 절차를 명세한 문서

 

* 테스트 오라클

- 테스트의 결과가 참인지 거짓인지를 판단하기 위해서 사전에 정의된 참 값을 입력하여 비교하는 기법